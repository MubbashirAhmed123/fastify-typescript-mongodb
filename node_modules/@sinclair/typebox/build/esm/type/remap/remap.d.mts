import { TSchema } from '../schema/index.mjs';
import { TObject, TProperties } from '../object/index.mjs';
import { TConstructor } from '../constructor/index.mjs';
import { TFunction } from '../function/index.mjs';
import { TIntersect } from '../intersect/index.mjs';
import { TUnion } from '../union/index.mjs';
import { TTuple } from '../tuple/index.mjs';
import { TArray } from '../array/index.mjs';
import { TAsyncIterator } from '../async-iterator/index.mjs';
import { TIterator } from '../iterator/index.mjs';
import { TPromise } from '../promise/index.mjs';
import { TRecord, TRecordOrObject } from '../record/index.mjs';
export type TCallback = (schema: TSchema) => TSchema;
export interface TMapping {
    input: unknown;
    output: unknown;
}
type TApply<Type extends TSchema, Mapping extends TMapping, Mapped = (Mapping & {
    input: Type;
})['output'], Result = Mapped extends TSchema ? Mapped : never> = Result;
type TFromProperties<Properties extends TProperties, Mapping extends TMapping, Result extends TProperties = {
    [Key in keyof Properties]: TRemap<Properties[Key], Mapping>;
}> = Result;
type TFromTypes<Types extends TSchema[], Mapping extends TMapping, Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? TFromTypes<Right, Mapping, [...Result, TRemap<Left, Mapping>]> : Result);
type TFromType<Type extends TSchema, Mapping extends TMapping, Result extends TSchema = (TApply<Type, Mapping>)> = Result;
/** `[Internal]` Applies a recursive conditional remapping of a type and its sub type constituents */
export type TRemap<Type extends TSchema, Mapping extends TMapping, Mapped extends TSchema = TFromType<Type, Mapping>, Result extends TSchema = (Mapped extends TConstructor<infer Parameters extends TSchema[], infer ReturnType extends TSchema> ? TConstructor<TFromTypes<Parameters, Mapping>, TFromType<ReturnType, Mapping>> : Mapped extends TFunction<infer Parameters extends TSchema[], infer ReturnType extends TSchema> ? TFunction<TFromTypes<Parameters, Mapping>, TFromType<ReturnType, Mapping>> : Mapped extends TIntersect<infer Types extends TSchema[]> ? TIntersect<TFromTypes<Types, Mapping>> : Mapped extends TUnion<infer Types extends TSchema[]> ? TUnion<TFromTypes<Types, Mapping>> : Mapped extends TTuple<infer Types extends TSchema[]> ? TTuple<TFromTypes<Types, Mapping>> : Mapped extends TArray<infer Type extends TSchema> ? TArray<TFromType<Type, Mapping>> : Mapped extends TAsyncIterator<infer Type extends TSchema> ? TAsyncIterator<TFromType<Type, Mapping>> : Mapped extends TIterator<infer Type extends TSchema> ? TIterator<TFromType<Type, Mapping>> : Mapped extends TPromise<infer Type extends TSchema> ? TPromise<TFromType<Type, Mapping>> : Mapped extends TObject<infer Properties extends TProperties> ? TObject<TFromProperties<Properties, Mapping>> : Mapped extends TRecord<infer Key extends TSchema, infer Value extends TSchema> ? TRecordOrObject<TFromType<Key, Mapping>, TFromType<Value, Mapping>> : Mapped)> = Result;
/** `[Internal]` Applies a recursive conditional remapping of a type and its sub type constituents */
export declare function Remap(type: TSchema, callback: TCallback): TSchema;
export {};
